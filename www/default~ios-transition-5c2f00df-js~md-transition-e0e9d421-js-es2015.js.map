{"version":3,"sources":["./node_modules/@ionic/core/dist/esm/animation-22971d74.js"],"names":[],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,SAAS,IAAI,oBAAoB;AACrE;AACA;AACA,kBAAkB,aAAa,GAAG,GAAG,sBAAsB,EAAE;AAC7D,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,MAAM;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,aAAa,EAAE,GAAG,cAAc,EAAE,cAAc,aAAa,MAAM,GAAG,cAAc,EAAE;AAC/H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,eAAe;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mGAAmG,cAAc;AACjH;AACA,6FAA6F,WAAW;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,cAAc;AACjF;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,0CAA0C,wCAAwC;AAClF;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,mGAAmG,cAAc;AACjH;AACA,6FAA6F,WAAW;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,aAAa;AAChF;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,wBAAwB;AACvD;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,wBAAwB;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEgC","file":"default~ios-transition-5c2f00df-js~md-transition-e0e9d421-js-es2015.js","sourcesContent":["const setStyleProperty = (element, propertyName, value) => {\r\n    element.style.setProperty(propertyName, value);\r\n};\r\nconst removeStyleProperty = (element, propertyName) => {\r\n    element.style.removeProperty(propertyName);\r\n};\r\nconst animationEnd = (el, callback) => {\r\n    let unRegTrans;\r\n    const opts = { passive: true };\r\n    const unregister = () => {\r\n        if (unRegTrans) {\r\n            unRegTrans();\r\n        }\r\n    };\r\n    const onTransitionEnd = (ev) => {\r\n        if (el === ev.target) {\r\n            unregister();\r\n            callback(ev);\r\n        }\r\n    };\r\n    if (el) {\r\n        el.addEventListener('webkitAnimationEnd', onTransitionEnd, opts);\r\n        el.addEventListener('animationend', onTransitionEnd, opts);\r\n        unRegTrans = () => {\r\n            el.removeEventListener('webkitAnimationEnd', onTransitionEnd, opts);\r\n            el.removeEventListener('animationend', onTransitionEnd, opts);\r\n        };\r\n    }\r\n    return unregister;\r\n};\r\nconst generateKeyframeRules = (keyframes = []) => {\r\n    return keyframes.map(keyframe => {\r\n        const offset = keyframe.offset;\r\n        const frameString = [];\r\n        for (const property in keyframe) {\r\n            if (keyframe.hasOwnProperty(property) && property !== 'offset') {\r\n                frameString.push(`${property}: ${keyframe[property]};`);\r\n            }\r\n        }\r\n        return `${offset * 100}% { ${frameString.join(' ')} }`;\r\n    }).join(' ');\r\n};\r\nconst keyframeIds = [];\r\nconst generateKeyframeName = (keyframeRules) => {\r\n    let index = keyframeIds.indexOf(keyframeRules);\r\n    if (index < 0) {\r\n        index = (keyframeIds.push(keyframeRules) - 1);\r\n    }\r\n    return `ion-animation-${index}`;\r\n};\r\nconst getStyleContainer = (element) => {\r\n    const rootNode = element.getRootNode();\r\n    return (rootNode.head || rootNode);\r\n};\r\nconst createKeyframeStylesheet = (keyframeName, keyframeRules, element) => {\r\n    const styleContainer = getStyleContainer(element);\r\n    const existingStylesheet = styleContainer.querySelector('#' + keyframeName);\r\n    if (existingStylesheet) {\r\n        return existingStylesheet;\r\n    }\r\n    const stylesheet = (element.ownerDocument || document).createElement('style');\r\n    stylesheet.id = keyframeName;\r\n    stylesheet.innerHTML = `@keyframes ${keyframeName} { ${keyframeRules} } @keyframes ${keyframeName}-alt { ${keyframeRules} }`;\r\n    styleContainer.appendChild(stylesheet);\r\n    return stylesheet;\r\n};\r\nconst addClassToArray = (classes = [], className) => {\r\n    if (className !== undefined) {\r\n        const classNameToAppend = (Array.isArray(className)) ? className : [className];\r\n        return [...classes, ...classNameToAppend];\r\n    }\r\n    return classes;\r\n};\n\n// TODO: Add more tests. until then, be sure to manually test menu and swipe to go back/routing transitions\r\nconst createAnimation = () => {\r\n    let _delay;\r\n    let _duration;\r\n    let _easing;\r\n    let _iterations;\r\n    let _fill;\r\n    let _direction;\r\n    let _keyframes = [];\r\n    let beforeAddClasses = [];\r\n    let beforeRemoveClasses = [];\r\n    let initialized = false;\r\n    let parentAnimation;\r\n    let beforeStylesValue = {};\r\n    let afterAddClasses = [];\r\n    let afterRemoveClasses = [];\r\n    let afterStylesValue = {};\r\n    let numAnimationsRunning = 0;\r\n    let shouldForceLinearEasing = false;\r\n    let shouldForceSyncPlayback = false;\r\n    let cssAnimationsTimerFallback;\r\n    let forceDirectionValue;\r\n    let forceDurationValue;\r\n    let forceDelayValue;\r\n    let willComplete = true;\r\n    let finished = false;\r\n    let shouldCalculateNumAnimations = true;\r\n    let keyframeName;\r\n    let ani;\r\n    const onFinishCallbacks = [];\r\n    const onFinishOneTimeCallbacks = [];\r\n    const elements = [];\r\n    const childAnimations = [];\r\n    const stylesheets = [];\r\n    const _beforeAddReadFunctions = [];\r\n    const _beforeAddWriteFunctions = [];\r\n    const _afterAddReadFunctions = [];\r\n    const _afterAddWriteFunctions = [];\r\n    const webAnimations = [];\r\n    const supportsWebAnimations = (typeof window.Animation === 'function');\r\n    const ANIMATION_END_FALLBACK_PADDING_MS = 100;\r\n    /**\r\n     * Returns the raw Web Animations object\r\n     * for all elements in an Animation.\r\n     * This will return an empty array on\r\n     * browsers that do not support\r\n     * the Web Animations API.\r\n     */\r\n    const getWebAnimations = () => {\r\n        return webAnimations;\r\n    };\r\n    /**\r\n     * Destroy the animation and all child animations.\r\n     */\r\n    const destroy = () => {\r\n        cleanUp();\r\n        elements.length = 0;\r\n        childAnimations.length = 0;\r\n        clearOnFinish();\r\n        initialized = false;\r\n        shouldCalculateNumAnimations = true;\r\n        childAnimations.forEach(childAnimation => {\r\n            childAnimation.destroy();\r\n        });\r\n        return ani;\r\n    };\r\n    /**\r\n     * Cancels any Web Animations, removes\r\n     * any animation properties from the\r\n     * animation's elements, and removes the\r\n     * animation's stylesheets from the DOM.\r\n     */\r\n    const cleanUp = () => {\r\n        cleanUpElements();\r\n        cleanUpStyleSheets();\r\n    };\r\n    /**\r\n     * Add a callback to be run\r\n     * upon the animation ending\r\n     */\r\n    const onFinish = (callback, opts) => {\r\n        const callbacks = (opts && opts.oneTimeCallback) ? onFinishOneTimeCallbacks : onFinishCallbacks;\r\n        callbacks.push({ callback, opts });\r\n        return ani;\r\n    };\r\n    /**\r\n     * Clears all callbacks\r\n     */\r\n    const clearOnFinish = () => {\r\n        onFinishCallbacks.length = 0;\r\n        onFinishOneTimeCallbacks.length = 0;\r\n        return ani;\r\n    };\r\n    /**\r\n     * Cancels any Web Animations and removes\r\n     * any animation properties from the\r\n     * the animation's elements.\r\n     */\r\n    const cleanUpElements = () => {\r\n        if (supportsWebAnimations) {\r\n            getWebAnimations().forEach(animation => {\r\n                animation.cancel();\r\n            });\r\n            webAnimations.length = 0;\r\n        }\r\n        else {\r\n            elements.forEach(element => {\r\n                removeStyleProperty(element, 'animation-name');\r\n                removeStyleProperty(element, 'animation-duration');\r\n                removeStyleProperty(element, 'animation-timing-function');\r\n                removeStyleProperty(element, 'animation-iteration-count');\r\n                removeStyleProperty(element, 'animation-delay');\r\n                removeStyleProperty(element, 'animation-play-state');\r\n                removeStyleProperty(element, 'animation-fill-mode');\r\n                removeStyleProperty(element, 'animation-direction');\r\n            });\r\n        }\r\n    };\r\n    /**\r\n     * Removes the animation's stylesheets\r\n     * from the DOM.\r\n     */\r\n    const cleanUpStyleSheets = () => {\r\n        stylesheets.forEach(stylesheet => {\r\n            stylesheet.parentNode.removeChild(stylesheet);\r\n        });\r\n        stylesheets.length = 0;\r\n    };\r\n    /**\r\n     * Add a function that performs a\r\n     * DOM read to be run before the\r\n     * animation starts\r\n     */\r\n    const beforeAddRead = (readFn) => {\r\n        _beforeAddReadFunctions.push(readFn);\r\n        return ani;\r\n    };\r\n    /**\r\n     * Add a function that performs a\r\n     * DOM write to be run before the\r\n     * animation starts\r\n     */\r\n    const beforeAddWrite = (writeFn) => {\r\n        _beforeAddWriteFunctions.push(writeFn);\r\n        return ani;\r\n    };\r\n    /**\r\n     * Add a function that performs a\r\n     * DOM read to be run after the\r\n     * animation end\r\n     */\r\n    const afterAddRead = (readFn) => {\r\n        _afterAddReadFunctions.push(readFn);\r\n        return ani;\r\n    };\r\n    /**\r\n     * Add a function that performs a\r\n     * DOM write to be run after the\r\n     * animation end\r\n     */\r\n    const afterAddWrite = (writeFn) => {\r\n        _afterAddWriteFunctions.push(writeFn);\r\n        return ani;\r\n    };\r\n    /**\r\n     * Add a class to the animation's\r\n     * elements before the animation starts\r\n     */\r\n    const beforeAddClass = (className) => {\r\n        beforeAddClasses = addClassToArray(beforeAddClasses, className);\r\n        return ani;\r\n    };\r\n    /**\r\n     * Remove a class from the animation's\r\n     * elements before the animation starts\r\n     */\r\n    const beforeRemoveClass = (className) => {\r\n        beforeRemoveClasses = addClassToArray(beforeRemoveClasses, className);\r\n        return ani;\r\n    };\r\n    /**\r\n     * Set CSS inline styles to the animation's\r\n     * elements before the animation begins.\r\n     */\r\n    const beforeStyles = (styles = {}) => {\r\n        beforeStylesValue = styles;\r\n        return ani;\r\n    };\r\n    /**\r\n     * Clear CSS inline styles from the animation's\r\n     * elements before the animation begins.\r\n     */\r\n    const beforeClearStyles = (propertyNames = []) => {\r\n        for (const property of propertyNames) {\r\n            beforeStylesValue[property] = '';\r\n        }\r\n        return ani;\r\n    };\r\n    /**\r\n     * Add CSS class to the animation's\r\n     * elements after the animation ends.\r\n     */\r\n    const afterAddClass = (className) => {\r\n        afterAddClasses = addClassToArray(afterAddClasses, className);\r\n        return ani;\r\n    };\r\n    /**\r\n     * Remove CSS class from the animation's\r\n     * elements after the animation ends.\r\n     */\r\n    const afterRemoveClass = (className) => {\r\n        afterRemoveClasses = addClassToArray(afterRemoveClasses, className);\r\n        return ani;\r\n    };\r\n    /**\r\n     * Set CSS inline styles to the animation's\r\n     * elements after the animation ends.\r\n     */\r\n    const afterStyles = (styles = {}) => {\r\n        afterStylesValue = styles;\r\n        return ani;\r\n    };\r\n    /**\r\n     * Clear CSS inline styles from the animation's\r\n     * elements after the animation ends.\r\n     */\r\n    const afterClearStyles = (propertyNames = []) => {\r\n        for (const property of propertyNames) {\r\n            afterStylesValue[property] = '';\r\n        }\r\n        return ani;\r\n    };\r\n    /**\r\n     * Returns the animation's fill mode.\r\n     */\r\n    const getFill = () => {\r\n        if (_fill !== undefined) {\r\n            return _fill;\r\n        }\r\n        if (parentAnimation) {\r\n            return parentAnimation.getFill();\r\n        }\r\n        return undefined;\r\n    };\r\n    /**\r\n     * Returns the animation's direction.\r\n     */\r\n    const getDirection = () => {\r\n        if (forceDirectionValue !== undefined) {\r\n            return forceDirectionValue;\r\n        }\r\n        if (_direction !== undefined) {\r\n            return _direction;\r\n        }\r\n        if (parentAnimation) {\r\n            return parentAnimation.getDirection();\r\n        }\r\n        return undefined;\r\n    };\r\n    /**\r\n     * Returns the animation's easing.\r\n     */\r\n    const getEasing = () => {\r\n        if (shouldForceLinearEasing) {\r\n            return 'linear';\r\n        }\r\n        if (_easing !== undefined) {\r\n            return _easing;\r\n        }\r\n        if (parentAnimation) {\r\n            return parentAnimation.getEasing();\r\n        }\r\n        return undefined;\r\n    };\r\n    /**\r\n     * Gets the animation's duration in milliseconds.\r\n     */\r\n    const getDuration = () => {\r\n        if (shouldForceSyncPlayback) {\r\n            return 0;\r\n        }\r\n        if (forceDurationValue !== undefined) {\r\n            return forceDurationValue;\r\n        }\r\n        if (_duration !== undefined) {\r\n            return _duration;\r\n        }\r\n        if (parentAnimation) {\r\n            return parentAnimation.getDuration();\r\n        }\r\n        return undefined;\r\n    };\r\n    /**\r\n     * Gets the number of iterations the animation will run.\r\n     */\r\n    const getIterations = () => {\r\n        if (_iterations !== undefined) {\r\n            return _iterations;\r\n        }\r\n        if (parentAnimation) {\r\n            return parentAnimation.getIterations();\r\n        }\r\n        return undefined;\r\n    };\r\n    /**\r\n     * Gets the animation's delay in milliseconds.\r\n     */\r\n    const getDelay = () => {\r\n        if (forceDelayValue !== undefined) {\r\n            return forceDelayValue;\r\n        }\r\n        if (_delay !== undefined) {\r\n            return _delay;\r\n        }\r\n        if (parentAnimation) {\r\n            return parentAnimation.getDelay();\r\n        }\r\n        return undefined;\r\n    };\r\n    /**\r\n     * Get an array of keyframes for the animation.\r\n     */\r\n    const getKeyframes = () => {\r\n        return _keyframes;\r\n    };\r\n    /**\r\n     * Sets whether the animation should play forwards,\r\n     * backwards, or alternating back and forth.\r\n     */\r\n    const direction = (animationDirection) => {\r\n        _direction = animationDirection;\r\n        update(true);\r\n        return ani;\r\n    };\r\n    /**\r\n     * Sets how the animation applies styles to its\r\n     * elements before and after the animation's execution.\r\n     */\r\n    const fill = (animationFill) => {\r\n        _fill = animationFill;\r\n        update(true);\r\n        return ani;\r\n    };\r\n    /**\r\n     * Sets when an animation starts (in milliseconds).\r\n     */\r\n    const delay = (animationDelay) => {\r\n        _delay = animationDelay;\r\n        update(true);\r\n        return ani;\r\n    };\r\n    /**\r\n     * Sets how the animation progresses through the\r\n     * duration of each cycle.\r\n     */\r\n    const easing = (animationEasing) => {\r\n        _easing = animationEasing;\r\n        update(true);\r\n        return ani;\r\n    };\r\n    /**\r\n     * Sets the length of time the animation takes\r\n     * to complete one cycle.\r\n     */\r\n    const duration = (animationDuration) => {\r\n        _duration = animationDuration;\r\n        update(true);\r\n        return ani;\r\n    };\r\n    /**\r\n     * Sets the number of times the animation cycle\r\n     * should be played before stopping.\r\n     */\r\n    const iterations = (animationIterations) => {\r\n        _iterations = animationIterations;\r\n        update(true);\r\n        return ani;\r\n    };\r\n    /**\r\n     * Sets the parent animation.\r\n     */\r\n    const parent = (animation) => {\r\n        parentAnimation = animation;\r\n        return ani;\r\n    };\r\n    /**\r\n     * Add one or more elements to the animation\r\n     */\r\n    const addElement = (el) => {\r\n        if (el != null) {\r\n            if (el.nodeType === 1) {\r\n                elements.push(el);\r\n            }\r\n            else if (el.length >= 0) {\r\n                for (let i = 0; i < el.length; i++) {\r\n                    elements.push(el[i]);\r\n                }\r\n            }\r\n            else {\r\n                console.error('Invalid addElement value');\r\n            }\r\n        }\r\n        return ani;\r\n    };\r\n    /**\r\n     * Group one or more animations together to be controlled by a parent animation.\r\n     */\r\n    const addAnimation = (animationToAdd) => {\r\n        if (animationToAdd != null) {\r\n            const parentAnim = ani;\r\n            const animationsToAdd = animationToAdd;\r\n            if (animationsToAdd.length >= 0) {\r\n                for (const animation of animationsToAdd) {\r\n                    animation.parent(parentAnim);\r\n                    childAnimations.push(animation);\r\n                }\r\n            }\r\n            else {\r\n                animationToAdd.parent(parentAnim);\r\n                childAnimations.push(animationToAdd);\r\n            }\r\n        }\r\n        return ani;\r\n    };\r\n    /**\r\n     * Set the keyframes for the animation.\r\n     */\r\n    const keyframes = (keyframeValues) => {\r\n        _keyframes = keyframeValues;\r\n        return ani;\r\n    };\r\n    /**\r\n     * Runs all before read callbacks\r\n     */\r\n    const runBeforeRead = () => {\r\n        _beforeAddReadFunctions.forEach(callback => {\r\n            callback();\r\n        });\r\n    };\r\n    /**\r\n     * Runs all before write callbacks\r\n     */\r\n    const runBeforeWrite = () => {\r\n        _beforeAddWriteFunctions.forEach(callback => {\r\n            callback();\r\n        });\r\n    };\r\n    /**\r\n     * Updates styles and classes before animation runs\r\n     */\r\n    const runBeforeStyles = () => {\r\n        const addClasses = beforeAddClasses;\r\n        const removeClasses = beforeRemoveClasses;\r\n        const styles = beforeStylesValue;\r\n        elements.forEach((el) => {\r\n            const elementClassList = el.classList;\r\n            elementClassList.add(...addClasses);\r\n            elementClassList.remove(...removeClasses);\r\n            for (const property in styles) {\r\n                if (styles.hasOwnProperty(property)) {\r\n                    setStyleProperty(el, property, styles[property]);\r\n                }\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * Run all \"before\" animation hooks.\r\n     */\r\n    const beforeAnimation = () => {\r\n        runBeforeRead();\r\n        runBeforeWrite();\r\n        runBeforeStyles();\r\n    };\r\n    /**\r\n     * Runs all after read callbacks\r\n     */\r\n    const runAfterRead = () => {\r\n        _afterAddReadFunctions.forEach(callback => {\r\n            callback();\r\n        });\r\n    };\r\n    /**\r\n     * Runs all after write callbacks\r\n     */\r\n    const runAfterWrite = () => {\r\n        _afterAddWriteFunctions.forEach(callback => {\r\n            callback();\r\n        });\r\n    };\r\n    /**\r\n     * Updates styles and classes before animation ends\r\n     */\r\n    const runAfterStyles = () => {\r\n        const addClasses = afterAddClasses;\r\n        const removeClasses = afterRemoveClasses;\r\n        const styles = afterStylesValue;\r\n        elements.forEach((el) => {\r\n            const elementClassList = el.classList;\r\n            elementClassList.add(...addClasses);\r\n            elementClassList.remove(...removeClasses);\r\n            for (const property in styles) {\r\n                if (styles.hasOwnProperty(property)) {\r\n                    setStyleProperty(el, property, styles[property]);\r\n                }\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * Run all \"after\" animation hooks.\r\n     */\r\n    const afterAnimation = () => {\r\n        clearCSSAnimationsTimeout();\r\n        runAfterRead();\r\n        runAfterWrite();\r\n        runAfterStyles();\r\n        const didComplete = willComplete;\r\n        onFinishCallbacks.forEach(onFinishCallback => {\r\n            onFinishCallback.callback(didComplete, ani);\r\n        });\r\n        onFinishOneTimeCallbacks.forEach(onFinishCallback => {\r\n            onFinishCallback.callback(didComplete, ani);\r\n        });\r\n        onFinishOneTimeCallbacks.length = 0;\r\n        shouldCalculateNumAnimations = true;\r\n        finished = true;\r\n    };\r\n    const animationFinish = () => {\r\n        if (numAnimationsRunning === 0) {\r\n            return;\r\n        }\r\n        numAnimationsRunning--;\r\n        if (numAnimationsRunning === 0) {\r\n            afterAnimation();\r\n            if (parentAnimation) {\r\n                parentAnimation.animationFinish();\r\n            }\r\n        }\r\n    };\r\n    const initializeCSSAnimation = (toggleAnimationName = true) => {\r\n        cleanUpStyleSheets();\r\n        elements.forEach(element => {\r\n            if (_keyframes.length > 0) {\r\n                const keyframeRules = generateKeyframeRules(_keyframes);\r\n                keyframeName = generateKeyframeName(keyframeRules);\r\n                const stylesheet = createKeyframeStylesheet(keyframeName, keyframeRules, element);\r\n                stylesheets.push(stylesheet);\r\n                setStyleProperty(element, 'animation-duration', (getDuration() !== undefined) ? `${getDuration()}ms` : null);\r\n                setStyleProperty(element, 'animation-timing-function', getEasing() || null);\r\n                setStyleProperty(element, 'animation-delay', (getDelay() !== undefined) ? `${getDelay()}ms` : null);\r\n                setStyleProperty(element, 'animation-fill-mode', getFill() || null);\r\n                setStyleProperty(element, 'animation-direction', getDirection() || null);\r\n                const iterationsCount = (getIterations() !== undefined) ?\r\n                    (getIterations() === Infinity) ? 'infinite' : getIterations().toString()\r\n                    : null;\r\n                setStyleProperty(element, 'animation-iteration-count', iterationsCount);\r\n                setStyleProperty(element, 'animation-play-state', 'paused');\r\n                if (toggleAnimationName) {\r\n                    setStyleProperty(element, 'animation-name', `${stylesheet.id}-alt`);\r\n                }\r\n                requestAnimationFrame(() => {\r\n                    setStyleProperty(element, 'animation-name', stylesheet.id || null);\r\n                });\r\n            }\r\n        });\r\n    };\r\n    const initializeWebAnimation = () => {\r\n        elements.forEach(element => {\r\n            const animation = element.animate(_keyframes, {\r\n                delay: getDelay(),\r\n                duration: getDuration(),\r\n                easing: getEasing(),\r\n                iterations: getIterations(),\r\n                fill: getFill(),\r\n                direction: getDirection()\r\n            });\r\n            animation.pause();\r\n            webAnimations.push(animation);\r\n        });\r\n        if (getWebAnimations().length > 0) {\r\n            webAnimations[0].onfinish = () => {\r\n                animationFinish();\r\n            };\r\n        }\r\n    };\r\n    const initializeAnimation = (toggleAnimationName = true) => {\r\n        beforeAnimation();\r\n        if (_keyframes.length > 0) {\r\n            if (supportsWebAnimations) {\r\n                initializeWebAnimation();\r\n            }\r\n            else {\r\n                initializeCSSAnimation(toggleAnimationName);\r\n            }\r\n        }\r\n        initialized = true;\r\n    };\r\n    const setAnimationStep = (step) => {\r\n        step = Math.min(Math.max(step, 0), 0.999);\r\n        if (supportsWebAnimations) {\r\n            getWebAnimations().forEach(animation => {\r\n                animation.currentTime = animation.effect.getComputedTiming().delay + (getDuration() * step);\r\n                animation.pause();\r\n            });\r\n        }\r\n        else {\r\n            const animationDelay = getDelay() || 0;\r\n            const animationDuration = `-${animationDelay + (getDuration() * step)}ms`;\r\n            elements.forEach(element => {\r\n                if (_keyframes.length > 0) {\r\n                    setStyleProperty(element, 'animation-delay', animationDuration);\r\n                    setStyleProperty(element, 'animation-play-state', 'paused');\r\n                }\r\n            });\r\n        }\r\n    };\r\n    const updateWebAnimation = () => {\r\n        getWebAnimations().forEach(animation => {\r\n            animation.effect.updateTiming({\r\n                delay: getDelay(),\r\n                duration: getDuration(),\r\n                easing: getEasing(),\r\n                iterations: getIterations(),\r\n                fill: getFill(),\r\n                direction: getDirection()\r\n            });\r\n        });\r\n    };\r\n    const updateCSSAnimation = (toggleAnimationName = true) => {\r\n        elements.forEach(element => {\r\n            requestAnimationFrame(() => {\r\n                setStyleProperty(element, 'animation-name', keyframeName || null);\r\n                setStyleProperty(element, 'animation-duration', (getDuration() !== undefined) ? `${getDuration()}ms` : null);\r\n                setStyleProperty(element, 'animation-timing-function', getEasing() || null);\r\n                setStyleProperty(element, 'animation-delay', (getDelay() !== undefined) ? `${getDelay()}ms` : null);\r\n                setStyleProperty(element, 'animation-fill-mode', getFill() || null);\r\n                setStyleProperty(element, 'animation-direction', getDirection() || null);\r\n                const iterationsCount = (getIterations() !== undefined) ?\r\n                    (getIterations() === Infinity) ? 'infinite' : getIterations().toString()\r\n                    : null;\r\n                setStyleProperty(element, 'animation-iteration-count', iterationsCount);\r\n                if (toggleAnimationName) {\r\n                    setStyleProperty(element, 'animation-name', `${keyframeName}-alt`);\r\n                }\r\n                requestAnimationFrame(() => {\r\n                    setStyleProperty(element, 'animation-name', keyframeName || null);\r\n                });\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Updates any existing animations.\r\n     */\r\n    const update = (deep = false, toggleAnimationName = true) => {\r\n        if (deep) {\r\n            childAnimations.forEach(animation => {\r\n                animation.update(deep);\r\n            });\r\n        }\r\n        if (supportsWebAnimations) {\r\n            updateWebAnimation();\r\n        }\r\n        else {\r\n            updateCSSAnimation(toggleAnimationName);\r\n        }\r\n        return ani;\r\n    };\r\n    const progressStart = (forceLinearEasing = false) => {\r\n        childAnimations.forEach(animation => {\r\n            animation.progressStart(forceLinearEasing);\r\n        });\r\n        pauseAnimation();\r\n        shouldForceLinearEasing = forceLinearEasing;\r\n        if (!initialized) {\r\n            initializeAnimation();\r\n        }\r\n        else {\r\n            update();\r\n            setAnimationStep(0);\r\n        }\r\n        return ani;\r\n    };\r\n    const progressStep = (step) => {\r\n        childAnimations.forEach(animation => {\r\n            animation.progressStep(step);\r\n        });\r\n        if (getDuration() !== undefined) {\r\n            setAnimationStep(step);\r\n        }\r\n        return ani;\r\n    };\r\n    const progressEnd = (shouldComplete, step, dur) => {\r\n        shouldForceLinearEasing = false;\r\n        childAnimations.forEach(animation => {\r\n            animation.progressEnd(shouldComplete, step, dur);\r\n        });\r\n        if (dur !== undefined) {\r\n            forceDurationValue = dur;\r\n        }\r\n        finished = false;\r\n        willComplete = shouldComplete;\r\n        if (!shouldComplete) {\r\n            forceDirectionValue = (getDirection() === 'reverse') ? 'normal' : 'reverse';\r\n            if (supportsWebAnimations) {\r\n                update();\r\n                setAnimationStep(1 - step);\r\n            }\r\n            else {\r\n                forceDelayValue = ((1 - step) * getDuration()) * -1;\r\n                update(false, false);\r\n            }\r\n        }\r\n        else {\r\n            if (!supportsWebAnimations) {\r\n                forceDelayValue = (step * getDuration()) * -1;\r\n                update(false, false);\r\n            }\r\n        }\r\n        onFinish(() => {\r\n            willComplete = true;\r\n            forceDurationValue = undefined;\r\n            forceDirectionValue = undefined;\r\n            forceDelayValue = undefined;\r\n        }, {\r\n            oneTimeCallback: true\r\n        });\r\n        if (!parentAnimation) {\r\n            play();\r\n        }\r\n        return ani;\r\n    };\r\n    const pauseAnimation = () => {\r\n        if (initialized) {\r\n            if (supportsWebAnimations) {\r\n                getWebAnimations().forEach(animation => {\r\n                    animation.pause();\r\n                });\r\n            }\r\n            else {\r\n                elements.forEach(element => {\r\n                    setStyleProperty(element, 'animation-play-state', 'paused');\r\n                });\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Pause the animation.\r\n     */\r\n    const pause = () => {\r\n        childAnimations.forEach(animation => {\r\n            animation.pause();\r\n        });\r\n        pauseAnimation();\r\n        return ani;\r\n    };\r\n    /**\r\n     * Play the animation asynchronously.\r\n     * This returns a promise that resolves\r\n     * when the animation has ended.\r\n     */\r\n    const playAsync = () => {\r\n        return new Promise(resolve => {\r\n            onFinish(resolve, { oneTimeCallback: true });\r\n            play();\r\n            return ani;\r\n        });\r\n    };\r\n    /**\r\n     * Play the animation synchronously. This\r\n     * is the equivalent of running the animation\r\n     * with a duration of 0ms.\r\n     */\r\n    const playSync = () => {\r\n        shouldForceSyncPlayback = true;\r\n        onFinish(() => shouldForceSyncPlayback = false, { oneTimeCallback: true });\r\n        play();\r\n        return ani;\r\n    };\r\n    const onAnimationEndFallback = () => {\r\n        cssAnimationsTimerFallback = undefined;\r\n        animationFinish();\r\n    };\r\n    const clearCSSAnimationsTimeout = () => {\r\n        if (cssAnimationsTimerFallback) {\r\n            clearTimeout(cssAnimationsTimerFallback);\r\n        }\r\n    };\r\n    const playCSSAnimations = () => {\r\n        clearCSSAnimationsTimeout();\r\n        elements.forEach(element => {\r\n            if (_keyframes.length > 0) {\r\n                requestAnimationFrame(() => {\r\n                    setStyleProperty(element, 'animation-play-state', 'running');\r\n                });\r\n            }\r\n        });\r\n        if (_keyframes.length === 0 || elements.length === 0) {\r\n            animationFinish();\r\n        }\r\n        else {\r\n            /**\r\n             * This is a catchall in the event that a CSS Animation did not finish.\r\n             * The Web Animations API has mechanisms in place for preventing this.\r\n             * CSS Animations will not fire an `animationend` event\r\n             * for elements with `display: none`. The Web Animations API\r\n             * accounts for this, but using raw CSS Animations requires\r\n             * this workaround.\r\n             */\r\n            const animationDelay = getDelay() || 0;\r\n            const animationDuration = getDuration() || 0;\r\n            cssAnimationsTimerFallback = setTimeout(onAnimationEndFallback, animationDelay + animationDuration + ANIMATION_END_FALLBACK_PADDING_MS);\r\n            animationEnd(elements[0], () => {\r\n                clearCSSAnimationsTimeout();\r\n                /**\r\n                 * Ensure that clean up\r\n                 * is always done a frame\r\n                 * before the onFinish handlers\r\n                 * are fired. Otherwise, there\r\n                 * may be flickering if a new\r\n                 * animation is started on the same\r\n                 * element too quickly\r\n                 *\r\n                 * TODO: Is there a cleaner way to do this?\r\n                 */\r\n                requestAnimationFrame(() => {\r\n                    clearCSSAnimationPlayState();\r\n                    requestAnimationFrame(() => {\r\n                        animationFinish();\r\n                    });\r\n                });\r\n            });\r\n        }\r\n    };\r\n    const clearCSSAnimationPlayState = () => {\r\n        elements.forEach(element => {\r\n            removeStyleProperty(element, 'animation-duration');\r\n            removeStyleProperty(element, 'animation-delay');\r\n            removeStyleProperty(element, 'animation-play-state');\r\n        });\r\n    };\r\n    const playWebAnimations = () => {\r\n        getWebAnimations().forEach(animation => {\r\n            animation.play();\r\n        });\r\n        if (_keyframes.length === 0 || elements.length === 0) {\r\n            animationFinish();\r\n        }\r\n    };\r\n    const resetAnimation = () => {\r\n        if (supportsWebAnimations) {\r\n            setAnimationStep(0);\r\n        }\r\n        else {\r\n            updateCSSAnimation();\r\n        }\r\n    };\r\n    /**\r\n     * Play the animation\r\n     */\r\n    const play = () => {\r\n        if (!initialized) {\r\n            initializeAnimation();\r\n        }\r\n        if (finished) {\r\n            resetAnimation();\r\n            finished = false;\r\n        }\r\n        if (shouldCalculateNumAnimations) {\r\n            numAnimationsRunning = childAnimations.length + 1;\r\n            shouldCalculateNumAnimations = false;\r\n        }\r\n        childAnimations.forEach(animation => {\r\n            animation.play();\r\n        });\r\n        if (supportsWebAnimations) {\r\n            playWebAnimations();\r\n        }\r\n        else {\r\n            playCSSAnimations();\r\n        }\r\n        return ani;\r\n    };\r\n    /**\r\n     * Stop the animation and reset\r\n     * all elements to their initial state\r\n     */\r\n    const stop = () => {\r\n        childAnimations.forEach(animation => {\r\n            animation.stop();\r\n        });\r\n        if (initialized) {\r\n            cleanUp();\r\n            initialized = false;\r\n        }\r\n        return ani;\r\n    };\r\n    const from = (property, value) => {\r\n        const firstFrame = _keyframes[0];\r\n        if (firstFrame != null && (firstFrame.offset === undefined || firstFrame.offset === 0)) {\r\n            firstFrame[property] = value;\r\n        }\r\n        else {\r\n            const object = {\r\n                offset: 0\r\n            };\r\n            object[property] = value;\r\n            _keyframes = [\r\n                object,\r\n                ..._keyframes\r\n            ];\r\n        }\r\n        return ani;\r\n    };\r\n    const to = (property, value) => {\r\n        const lastFrame = _keyframes[_keyframes.length - 1];\r\n        if (lastFrame != null && (lastFrame.offset === undefined || lastFrame.offset === 1)) {\r\n            lastFrame[property] = value;\r\n        }\r\n        else {\r\n            const object = {\r\n                offset: 1\r\n            };\r\n            object[property] = value;\r\n            _keyframes = [\r\n                ..._keyframes,\r\n                object\r\n            ];\r\n        }\r\n        return ani;\r\n    };\r\n    const fromTo = (property, fromValue, toValue) => {\r\n        return from(property, fromValue).to(property, toValue);\r\n    };\r\n    return ani = {\r\n        parentAnimation,\r\n        elements,\r\n        childAnimations,\r\n        animationFinish,\r\n        from,\r\n        to,\r\n        fromTo,\r\n        parent,\r\n        play,\r\n        playAsync,\r\n        playSync,\r\n        pause,\r\n        stop,\r\n        destroy,\r\n        keyframes,\r\n        addAnimation,\r\n        addElement,\r\n        update,\r\n        fill,\r\n        direction,\r\n        iterations,\r\n        duration,\r\n        easing,\r\n        delay,\r\n        getWebAnimations,\r\n        getKeyframes,\r\n        getFill,\r\n        getDirection,\r\n        getDelay,\r\n        getIterations,\r\n        getEasing,\r\n        getDuration,\r\n        afterAddRead,\r\n        afterAddWrite,\r\n        afterClearStyles,\r\n        afterStyles,\r\n        afterRemoveClass,\r\n        afterAddClass,\r\n        beforeAddRead,\r\n        beforeAddWrite,\r\n        beforeClearStyles,\r\n        beforeStyles,\r\n        beforeRemoveClass,\r\n        beforeAddClass,\r\n        onFinish,\r\n        clearOnFinish,\r\n        progressStart,\r\n        progressStep,\r\n        progressEnd\r\n    };\r\n};\n\nexport { createAnimation as c };\n"],"sourceRoot":""}